// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
}

// User and Player Profile
model User {
  id        String   @id @default(cuid())
  email     String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  playerProfiles PlayerProfile[]
  decks          Deck[]
}

model PlayerProfile {
  id        String   @id @default(cuid())
  playerTag String   @unique
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  battles BattleSnapshot[]
}

// Deck Management
model Deck {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  cards     String // JSON array of 8 card names
  grade     String? // S, A, B, C, D, F
  avgElixir Float?
  analysis  String? // JSON with detailed analysis
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Battle and Replay Analysis
model BattleSnapshot {
  id              String         @id @default(cuid())
  playerProfileId String
  playerProfile   PlayerProfile  @relation(fields: [playerProfileId], references: [id])
  battleTime      DateTime
  battleType      String
  result          String // win, loss, draw
  trophies        Int?
  opponentTag     String?
  opponentDeck    String // JSON array
  playerDeck      String // JSON array
  rawData         String // Full JSON from API
  createdAt       DateTime       @default(now())

  patterns MistakePattern[]
}

model MistakePattern {
  id              String         @id @default(cuid())
  battleId        String
  battle          BattleSnapshot @relation(fields: [battleId], references: [id])
  patternType     String // e.g., "spell_timing", "elixir_waste", "archetype_counter"
  description     String
  recommendation  String
  severity        String // low, medium, high
  createdAt       DateTime       @default(now())
}

// Knowledge Base (RAG)
model Source {
  id          String        @id @default(cuid())
  type        String // "seed_markdown", "youtube", "article", "guide"
  url         String?
  title       String
  author      String?
  tags        String? // JSON array
  status      String        @default("pending") // pending, processing, completed, failed
  metadata    String? // JSON with extra info
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  chunks SourceChunk[]
}

model SourceChunk {
  id         String   @id @default(cuid())
  sourceId   String
  source     Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  content    String // The actual text chunk
  embedding  String? // JSON array of floats (vector embedding)
  chunkIndex Int // Order in the source
  metadata   String? // JSON with context (e.g., timestamp for video, section for article)
  createdAt  DateTime @default(now())

  @@index([sourceId])
}

// Counter Guide Data
model CounterPlacement {
  id          String   @id @default(cuid())
  cardName    String
  counterCard String
  placement   String // JSON with tile coordinates
  steps       String // JSON array of steps
  notes       String?
  difficulty  String? // easy, medium, hard
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([cardName])
}

// Tutorial Lessons
model Tutorial {
  id          String   @id @default(cuid())
  title       String
  category    String // "basics", "synergy", "advanced", etc.
  content     String // Markdown or JSON
  difficulty  String // beginner, intermediate, advanced
  order       Int
  sourceId    String? // Link to source if applicable
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
}
